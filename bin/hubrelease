#!/usr/bin/env ruby
STDOUT.sync = true

$:.unshift File.join(File.dirname(__FILE__), "..", "lib")

require "optparse"
require "hubrelease"

options = {}
opts = OptionParser.new do |o|
  o.banner = "Usage: hubrelease [options]"

  o.on "--repo USER/REPO", "Repository (user/repo)" do |repo|
    options[:repo] = repo
  end

  o.on "--init", "Generate first release" do |init|
    options[:init] = init
  end

  o.on "--output", "Print release notes to stdout, don't create a GitHub release" do |output|
    options[:output] = output
  end

  o.on "--prev PREVIOUS", "Previous release tag name" do |prev|
    options[:prev] = prev
  end

  o.on "--new NEW", "Next release tag name" do |new|
    options[:new] = new
  end

  o.on "--reverts", "Include revert commits in the release notes" do |reverts|
    options[:reverts] = reverts
  end

  o.on "--token TOKEN", "GitHub API token" do |token|
    options[:token] = token
  end

  o.on "--label LABEL", "Label to include on issues/pull requests labelled with the label" do |label|
    options[:labels] ||= []
    options[:labels] = label
  end

  o.on "--attach FILE", "File path to attach to release" do |attach|
    options[:attach] ||= []
    options[:attach] << attach
  end

  o.on_tail "-h", "--help", "Show this message" do
    puts o
    exit
  end
end

begin
  opts.parse!

  if options[:init]
    mandatory = [:repo, :token, :new]
  else
    mandatory = [:repo, :prev, :new, :token]
  end

  missing = mandatory.select{ |param| options[param].nil? }

  unless missing.empty?
    puts "Missing options: #{missing.join(', ')}"
    puts opts
    exit
  end
rescue OptionParser::InvalidOption, OptionParser::MissingArgument
  puts $!.to_s
  puts opts
  exit
end

HubRelease::Generator.generate(options)
